After finishing workshop3, I’ve learned how to design and code a class template, specialize both a templated class variable for a particular type and a member function of a templated class to process a particular type. Also, I get to know a class can be derived directly from a templated family of classes. In the follow-up I’ll explain them in more details and answer all the questions been asked in this workshop.

To start with, we did something differently comparing to the other workshops which is that we didn’t split our modules into header files and cpp files. The reason for that is because when instantiating a template, the compiler creates a new class with any given template argument, consequently, the compiler needs to have access to the implementation of the methods, to instantiate them with the template argument (T collection[N] -> PairSummable collection[15]). If those implementations were not in the header, they wouldn’t be accessible, and therefor the compiler wouldn’t be able to instantiate the template.

We specialize the operator+= function in class PairSummable for type string, so we can concatenate the stored values for the special output we want for later use. Defining class variables f_width and initial outside the class definition follows the one definition rule since they are both static. 

The compiler generates class definitions for each template instantiation and replaces the type T with the argument specified in the instantiation of the PairSummable template. For example, PairSummable<int, std::string> record(ticketType, number). We set the default parameter to initial in the PairSummable constructor so that when an empty value is passed in, the object will be set to a saft empty state without any error.
